

<!DOCTYPE html>
<html>
  <head>
    <title>
	クラスタ管理 :: テックまとめ
</title>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="revised" content="2021-07-07T20:49:24 JST">
<meta name="description" content="備忘録用メモサイト">



<title>クラスタ管理 :: テックまとめ</title>

<link rel="shortcut icon" href='/images/favicon.png' type="image/x-icon" />

<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.css">

<script src='https://code.jquery.com/jquery-3.5.1.min.js'></script>

<link href='https://fonts.googleapis.com/css?family=Montserrat:400,700' rel="stylesheet">



<link rel="stylesheet" type="text/css" href='https://tanakakns.github.io/sass/layout.css'>
<link rel="stylesheet" type="text/css" href='https://tanakakns.github.io/css/style.main.css'>
<link rel="stylesheet" type="text/css" href='https://tanakakns.github.io/css/style.menu.css'>
<link rel="stylesheet" type="text/css" href='https://tanakakns.github.io/sass/shortcodes/notice.css'>
<link rel="stylesheet" type="text/css" href='https://tanakakns.github.io/sass/shortcodes/tabs.css'>
<link rel="stylesheet" type="text/css" href='https://tanakakns.github.io/sass/shortcodes/panel.css'>
<link rel="stylesheet" type="text/css" href='https://tanakakns.github.io/sass/shortcodes/columns.css'>
<link rel="stylesheet" type="text/css" href='https://tanakakns.github.io/sass/shortcodes/children.css'>
<link rel="stylesheet" type="text/css" href='https://tanakakns.github.io/sass/shortcodes/attachments.css'>
<link rel="stylesheet" type="text/css" href='https://tanakakns.github.io/sass/shortcodes/alert.css'>
<link rel="stylesheet" type="text/css" href='/css/docport.css'>

<script src='/js/docport.js'></script>
<script type="text/javascript">
      var baseurl = "https:\/\/tanakakns.github.io\/";
</script>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-42388425-3', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </head>

  <body data-url="/kubernetes/administration/"

  class="hidetoc hidenextpage ">

<style type="text/css">
  #debug{
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    line-height: 3.5rem;
    margin-bottom: .35rem;
    padding: 0 2rem;
    position: fixed;
    left: 0;      right: 0;     top: 0;
   
    top:0px;
    
    min-height: 150px;

    background-color: white;
    border: 3px solid red;
    z-index: 10000 ;
    word-wrap: all;
    overflow: auto;
  }
</style>
 


    
    
    <header style="">
        <div>
    
    <div class="burger ">
        <a href="javascript:void(0);" style="font-size:15px;" onclick="$('article > aside').toggleClass('responsive')">&#9776;</a>
    </div>
    

    <div>

		
	
			
		
	    	<a class='baselink' href='https://tanakakns.github.io/'>テックまとめ</a>
	  	
	</div>

</div>
    </header>
    

    <article>
      
      <aside class="">
        

		
	
			
		
	    	
	  	
	<div id="close_menu">
  <a href="javascript:void(0);" style="font-size:15px;" onclick="$('article > aside').toggleClass('responsive')">
      <i class="fa fa-lg fa-times"></i>
  </a>
</div>

<ul class="menu">

    <li data-nav-id="https://tanakakns.github.io/design/" class="dd-item haschildren
        item_level_$level
        ">

      
      
      
      <i class="fas fa-chevron-right ddexp"></i>
        
      
          <a href="/design/">設計</a>
      
        <ul>
              

    <li data-nav-id="https://tanakakns.github.io/design/architecture/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/design/architecture/">アーキテクチャ</a>
      
        
      
    </li>
        </ul>
    </li>
    

    <li data-nav-id="https://tanakakns.github.io/mac/" class="dd-item haschildren
        item_level_$level
        ">

      
      
      
      <i class="fas fa-chevron-right ddexp"></i>
        
      
          <a href="/mac/">Mac開発環境</a>
      
        <ul>
              

    <li data-nav-id="https://tanakakns.github.io/mac/os-settings/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/mac/os-settings/">OSの設定</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/mac/homebrew/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/mac/homebrew/">Homebrew</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/mac/asdf/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/mac/asdf/">asdf</a>
      
        
      
    </li>
        </ul>
    </li>
    

    <li data-nav-id="https://tanakakns.github.io/git/" class="dd-item haschildren
        item_level_$level
        ">

      
      
      
      <i class="fas fa-chevron-right ddexp"></i>
        
      
          <a href="/git/">Git</a>
      
        <ul>
              

    <li data-nav-id="https://tanakakns.github.io/git/initial-setting/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/git/initial-setting/">初期設定</a>
      
        
      
    </li>
        </ul>
    </li>
    

    <li data-nav-id="https://tanakakns.github.io/go/" class="dd-item haschildren
        item_level_$level
        ">

      
      
      
      <i class="fas fa-chevron-right ddexp"></i>
        
      
          <a href="/go/">Go言語</a>
      
        <ul>
              

    <li data-nav-id="https://tanakakns.github.io/go/initial-setting/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/go/initial-setting/">初期設定</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/go/grammar/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/go/grammar/">文法</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/go/naming/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/go/naming/">命名規則</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/go/pattern/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/go/pattern/">パターン</a>
      
        
      
    </li>
        </ul>
    </li>
    

    <li data-nav-id="https://tanakakns.github.io/database/" class="dd-item haschildren
        item_level_$level
        ">

      
      
      
      <i class="fas fa-chevron-right ddexp"></i>
        
      
          <a href="/database/">Database</a>
      
        <ul>
              

    <li data-nav-id="https://tanakakns.github.io/database/rdb/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/database/rdb/">RDB</a>
      
        
      
    </li>
        </ul>
    </li>
    

    <li data-nav-id="https://tanakakns.github.io/aws/" class="dd-item
        item_level_$level
        ">

      
      
      
      
        
      
          <a href="/aws/">AWS</a>
      
    </li>
    

    <li data-nav-id="https://tanakakns.github.io/gcp/" class="dd-item haschildren
        item_level_$level
        ">

      
      
      
      <i class="fas fa-chevron-right ddexp"></i>
        
      
          <a href="/gcp/">GCP</a>
      
        <ul>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/gcp-aws/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/gcp-aws/">GCP と AWS の比較</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/monitoring/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/monitoring/">監視</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/tools/" class="dd-item haschildren
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/tools/">ツール</a>
      <i class="fas fa-chevron-right ddexp"></i>
        
      
        <ul>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/tools/management-tools/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/tools/management-tools/">管理ツール</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/tools/dev-tools/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/tools/dev-tools/">開発ツール</a>
      
        
      
    </li>
        </ul>
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/access-control-and-security/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/access-control-and-security/">アクセス制御とセキュリティ</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/computing-hosting/" class="dd-item haschildren
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/computing-hosting/">コンピューティングとホスティング</a>
      <i class="fas fa-chevron-right ddexp"></i>
        
      
        <ul>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/computing-hosting/compute-engine/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/computing-hosting/compute-engine/">Compute Engine</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/computing-hosting/kubernetes-engine/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/computing-hosting/kubernetes-engine/">Google Kubernetes Engine</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/computing-hosting/app-engine/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/computing-hosting/app-engine/">App Engine</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/computing-hosting/cloud-functions/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/computing-hosting/cloud-functions/">Cloud Functions</a>
      
        
      
    </li>
        </ul>
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/storage/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/storage/">ストレージ</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/databases/" class="dd-item haschildren
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/databases/">データベース</a>
      <i class="fas fa-chevron-right ddexp"></i>
        
      
        <ul>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/databases/bigquery/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/databases/bigquery/">BigQuery</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/databases/sql/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/databases/sql/">Cloud SQL</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/databases/memorystore/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/databases/memorystore/">Memorystore</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/databases/spanner/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/databases/spanner/">Cloud Spanner</a>
      
        
      
    </li>
        </ul>
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/networking/" class="dd-item haschildren
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/networking/">ネットワーキング</a>
      <i class="fas fa-chevron-right ddexp"></i>
        
      
        <ul>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/networking/vpc/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/networking/vpc/">VPC</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/networking/load-balancing/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/networking/load-balancing/">Cloud Load Balancing</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/networking/iap/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/networking/iap/">Identity-Aware Proxy</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/networking/interconnect/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/networking/interconnect/">Cloud Interconnect</a>
      
        
      
    </li>
        </ul>
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/big-data/" class="dd-item haschildren
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/big-data/">ビッグデータ</a>
      <i class="fas fa-chevron-right ddexp"></i>
        
      
        <ul>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/big-data/pubsub/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/big-data/pubsub/">Cloud Pub/Sub</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/big-data/dataflow/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/big-data/dataflow/">Dataflow</a>
      
        
      
    </li>
        </ul>
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/gcp/machine-learning/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/gcp/machine-learning/">機械学習</a>
      
        
      
    </li>
        </ul>
    </li>
    

    <li data-nav-id="https://tanakakns.github.io/terraform/" class="dd-item haschildren
        item_level_$level
        ">

      
      
      
      <i class="fas fa-chevron-right ddexp"></i>
        
      
          <a href="/terraform/">Terraform</a>
      
        <ul>
              

    <li data-nav-id="https://tanakakns.github.io/terraform/basic/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/terraform/basic/">入門</a>
      
        
      
    </li>
        </ul>
    </li>
    

    <li data-nav-id="https://tanakakns.github.io/docker/" class="dd-item haschildren
        item_level_$level
        ">

      
      
      
      <i class="fas fa-chevron-right ddexp"></i>
        
      
          <a href="/docker/">Docker</a>
      
        <ul>
              

    <li data-nav-id="https://tanakakns.github.io/docker/basic/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/docker/basic/">入門</a>
      
        
      
    </li>
        </ul>
    </li>
    

    <li data-nav-id="https://tanakakns.github.io/kubernetes/" class="dd-item parent haschildren
        item_level_$level
        ">

      
      
      
      
          <i class="fas fa-chevron-down ddexp"></i>
        
      
          <a href="/kubernetes/">Kubernetes</a>
      
        <ul>
              

    <li data-nav-id="https://tanakakns.github.io/kubernetes/concept/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/kubernetes/concept/">概念整理</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/kubernetes/architecture/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/kubernetes/architecture/">アーキテクチャ</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/kubernetes/kubectl-plugin/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/kubernetes/kubectl-plugin/">kubectl plugin と Krew</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/kubernetes/command/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/kubernetes/command/">コマンド</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/kubernetes/manifest/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/kubernetes/manifest/">マニフェスト</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/kubernetes/administration/" class="dd-item parent active
        item_level_$level
        ">

      
      
      
      
          <a href="/kubernetes/administration/">クラスタ管理</a>
      
        
      
    </li>
        </ul>
    </li>
    

    <li data-nav-id="https://tanakakns.github.io/istio/" class="dd-item haschildren
        item_level_$level
        ">

      
      
      
      <i class="fas fa-chevron-right ddexp"></i>
        
      
          <a href="/istio/">Istio</a>
      
        <ul>
              

    <li data-nav-id="https://tanakakns.github.io/istio/basic/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/istio/basic/">入門</a>
      
        
      
    </li>
              

    <li data-nav-id="https://tanakakns.github.io/istio/concept/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/istio/concept/">概念整理</a>
      
        
      
    </li>
        </ul>
    </li>
    



</ul>

		
	
			
		
	    	
	  	
	
      </aside>
      

      <section class="page ">
      
	
		
    
    
    <nav id="ariane" aria-label="breadcrumb">
      <ol class="ariane">
        
  
  	
		
  
  	
	<li >
      <a class="text-link" href="https://tanakakns.github.io/">
        
      </a>
    </li>
	
  
    <li class="">
      <a class="text-link" href="/kubernetes/">
        Kubernetes
      </a>
    </li>
	
  	
  
    <li class="active">
      
        クラスタ管理
      
    </li>

      </ol>
    </nav>
    
    

    
		
        
		
		
		
		
		
		
		

		
			<h1>クラスタ管理</h1>
        

		
										
		

		
	

	
	
	






	<div class="content">
	    <p>Application Lifecycle Management について。</p>
<h2 ref="1-rolling-update-and-rollbacks" >1. Rolling Update and Rollbacks</h2><a class="anchor" id="1-rolling-update-and-rollbacks"></a>
<p>Deployment のマニフェストの <code>spec.template.spec.containers.image</code> を変更し <code>kubectl apply</code> すれば、デフォルトの設定で <strong>ローリングアップデート</strong> される。<br>
もしくは <code>kubectl set image deployment/&lt;deployment-name&gt; &lt;pod-name&gt;=&lt;image-name&gt;</code> で直接イメージを変更しても同様。<br>
ロールアウトの確認方法は以下の通り。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># rollout の状況を確認</span>
$ kubectl rollout status deployment &lt;deployment-name&gt;

<span style="color:#75715e"># これまでの rollout を確認</span>
$ kubectl rollout history deployment &lt;deployment-name&gt;

<span style="color:#75715e"># ロールバック</span>
$ kubectl rollout undo deployment &lt;deployment-name&gt;
</code></pre></div><p>なお、ローリングアップデートされる際は ReplicaSet が再度作成されている。</p>
<h2 ref="2-cluster-maintainance" >2. Cluster Maintainance</h2><a class="anchor" id="2-cluster-maintainance"></a>
<h3 ref="21-os-の更新" >2.1. OS の更新</h3><a class="anchor" id="21-os-の更新"></a>
<p>クラスタからノードが消失した場合、 <code>kube-scheduler</code> 起動時に設定したオプション <code>--pod-eviction-timeout=5m0s</code> が経過すると消失したノードに配置されていた Pod （ただし、 ReplicaSet の場合）は他のアクティブなノードで再作成される。（ ReplicaSet ではない場合は際作成されない）<br>
障害でノードが消失する場合は仕方ないが、メンテナンスでノードを停止する場合は、ノードから Pod を <strong>ドレイン</strong> して他のノードへ Pod を移す必要がある。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 指定ノードの Pod を Graceful Shutdown させ、徐々に Pod を退避する</span>
$ kubectl drain &lt;node-name&gt; <span style="color:#f92672">[</span>--ignore-daemonsets<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>--force<span style="color:#f92672">]</span>
</code></pre></div><p>なお、ノードをクラスタに復帰させた場合は <code>uncordon</code> する。（ cordon は遮蔽 の意）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ kubectl uncordon &lt;node-name&gt;

<span style="color:#75715e"># ちなみに以下のコマンドはノードの Pod を直ちに停止させる（ Graceful Shutdown しない）</span>
<span style="color:#75715e"># そして、停止した Pod を他のノードに退避させることもない</span>
$ kubectl cordon &lt;node-name&gt;
</code></pre></div><h3 ref="22-kubernetes-の更新" >2.2. Kubernetes の更新</h3><a class="anchor" id="22-kubernetes-の更新"></a>
<p>Kubernetes クラスタにインストール・実行されている各コンポーネントの更新方法について記載する。<br>
Kubernetes にインストールされているコンポーネントのバージョンは <code>kubectl get nodes</code> の <code>VERSION</code> 項目にて確認できる。<br>
ただし、 <code>etcd</code> や <code>CoreDNS</code> は <code>kube-apiserver</code> などの Kubernetes コンポーネントとは別プロジェクトであるためバージョニングが異なることに注意。</p>
<p>Kubernetes のコンポーネントは、マイナーバージョン 3 つまでであれば <strong>ライブアップグレード</strong> をサポートしている。<br>
しかしながら、一気にバージョンアップするのではなく、 1 つずつバージョンアップすることが推奨される。</p>
<ul>
<li>Master Nodes 、 Worker Nodes の順にアップグレードする</li>
<li>Master Nodes 上で以下を実行する
<ul>
<li>OS を確認する <code>cat /etc/*release*/</code>
<ul>
<li>OS に応じたアップグレード手順を実施する必要があるため</li>
<li>以下の参考 URL を見ながら実施すること</li>
</ul>
</li>
<li><code>kubeadm</code> を更新する： <code>apt-get upgrade -y kubeadm=1.12.0-00</code></li>
<li><code>kubeadm upgrade plan</code> でアップグレード情報を確認</li>
<li><code>kubeadm upgrade apply v1.13.3</code> でアップグレードを実行</li>
<li><code>kubectl get nodes</code> コマンド結果の <code>VERSION</code> を見てアップグレード出来ているか確認する</li>
<li>必要であれば後述の <code>kubelet</code> <code>kubectl</code> のバージョンアップも実施する</li>
</ul>
</li>
<li>Worker Nodes を 1 つずつアップグレードする（バージョンアップしたノードを足して、古いノードを削除、を繰り返してもいい）
<ul>
<li><code>kubectl drain &lt;node-name&gt;</code> @MasterNodes</li>
<li><code>kubeadm</code> を更新する： <code>apt-get upgrade -y kubeadm=1.12.0-00</code></li>
<li><code>kubelet</code> を更新する： <code>apt-get upgrade -y kubelet=1.12.0-00</code></li>
<li>設定を更新する： <code>kubeadm upgrade node config --kubelet-version v1.12.0</code></li>
<li><code>kubelet</code> を再起動する： <code>systemctl restart kubelet</code></li>
<li><code>kubectl get nodes</code> コマンド結果の <code>VERSION</code> を見てアップグレード出来ているか確認する</li>
<li><code>kubectl uncordon &lt;node-name&gt;</code> @MasterNodes</li>
</ul>
</li>
</ul>
<p>参考：<a href="https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">Upgrading kubeadm clusters</a></p>
<h2 ref="3-バックアップとリストア" >3. バックアップとリストア</h2><a class="anchor" id="3-バックアップとリストア"></a>
<p>バックアップとリスト対象になるものは以下</p>
<ul>
<li>Resource Configuration
<ul>
<li>Github などで管理</li>
<li>上記のように管理できていないものは <code>kubectl get all --all-namespaces -o yaml &gt; all-deploy-services.yaml</code> などで取得</li>
</ul>
</li>
<li>etcd Cluster
<ul>
<li>etcd の起動オプションに <code>--data-dir</code> があり、Master Nodes の各ディレクトリをバックアップする</li>
<li><code>ETCDCTL_API=3 etcdctl snapshot save snapshot.db</code> コマンドでバックアップ可能</li>
<li><code>ETCDCTL_API=3 etcdctl snapshot status snapshot.db</code> コマンドで内容を確認できる</li>
<li><code>service kube-apiserver stop</code> コマンドで <code>kube-apiserver</code> を停止させた後、 <code>ETCDCTL_API=3 etcdctl snapshot restore snapshot.db --data-dir=/var/lib/etcd-from-backup</code> でリストアする</li>
<li>etcd の起動オプション <code>--data-dir</code> や Static Pod であればマニフェストの設定を確認した後、 <code>systemctl daemon-reload &amp;&amp; service etcd restart</code> で再起動する</li>
<li>最後に <code>service kube-apiserver start</code> コマンドで <code>kube-apiserver</code> を起動</li>
</ul>
</li>
<li>Persistent Volumes</li>
</ul>
<p>なお、  <code>etcdctl</code> コマンドを打ってもエラーが発生する場合は、下記のようにエンドポイントや証明書を指定すること。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ETCDCTL_API<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span> etcdctl --endpoints<span style="color:#f92672">=</span>https://127.0.0.1:2379 --cacert<span style="color:#f92672">=</span>/etc/kubernetes/pki/etcd/ca.crt --cert<span style="color:#f92672">=</span>/etc/kubernetes/pki/etcd/server.crt --key<span style="color:#f92672">=</span>/etc/kubernetes/pki/etcd/server.key snapshot save /opt/snapshot-pre-boot.db

$ ETCDCTL_API<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span> etcdctl --endpoints<span style="color:#f92672">=</span>https://127.0.0.1:2379 --cacert<span style="color:#f92672">=</span>/etc/kubernetes/pki/etcd/ca.crt --cert<span style="color:#f92672">=</span>/etc/kubernetes/pki/etcd/server.crt --key<span style="color:#f92672">=</span>/etc/kubernetes/pki/etcd/server.key snapshot restore /opt/snapshot-pre-boot.db --data-dir<span style="color:#f92672">=</span>/var/lib/etcd-from-backup
</code></pre></div><p>参考： <a href="https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster">Backing up an etcd cluster</a></p>
<h2 ref="4-セキュリティ" >4. セキュリティ</h2><a class="anchor" id="4-セキュリティ"></a>
<p><code>kube-apiserver</code> に <code>kubectl</code> でアクセスする際は以下のセキュリティ事項がある。</p>
<ul>
<li>誰がアクセスするのか -&gt; Authentication / 認証
<ul>
<li>以下のような方法がある
<ul>
<li>Username / Password</li>
<li>Username / Token</li>
<li>Certificates</li>
<li>ID Providor や LDAP</li>
<li>Service Accounts</li>
</ul>
</li>
</ul>
</li>
<li>何を実行するのか  -&gt; Authorization / 認可・承認
<ul>
<li>以下のような方法がある
<ul>
<li>RBAC Authorization ( Role Based Access Control)</li>
<li>ABAC Authorization ( Attribute Based Access Control)</li>
<li>Node Authorization</li>
<li>Webhook Mode</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 ref="41-authentication--認証" >4.1. Authentication / 認証</h3><a class="anchor" id="41-authentication--認証"></a>
<p><strong>Account</strong> には以下の 2 種類がある。</p>
<ul>
<li><strong>User</strong>
<ul>
<li>管理者、開発者</li>
<li>Kubernetes は User を管理しない</li>
</ul>
</li>
<li><strong>Service Accounts</strong>
<ul>
<li>Bots など</li>
<li>Kubernetes は Service Accounts を管理する
<ul>
<li><code>kubectl create serviceaccount sa1</code></li>
<li><code>kubectl get serviceacceount</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 ref="411-パスワードトークン認証" >4.1.1. パスワード・トークン認証</h4><a class="anchor" id="411-パスワードトークン認証"></a>
<p><code>kube-apiserver</code> が 静的ファイルを用いてユーザ認証する方法は以下の通り。<br>
まず、以下のファイルを準備する。</p>
<pre><code class="language-csv:user-details.csv" data-lang="csv:user-details.csv"># Password,UserName,UserID
password123,user1,u0001
password123,user2,u0002
password123,user3,u0003
</code></pre><p>そして、上記のファイルを <code>kube-apiserver.service</code> の起動オプション <code>--basic-auth-file</code> に指定する。<br>
また、以下のように 4 項目目にグループを指定することもできるし、パスワードではなくトークンでもいい。（トークンファイルの場合は <code>--token-auth-file</code> オプションで指定 ）</p>
<pre><code class="language-csv:user-token-details.csv" data-lang="csv:user-token-details.csv"># Password,UserName,UserID,GroupID
token123,user1,u0001,group1
token123,user2,u0002,group1
token123,user3,u0003,group2
</code></pre><p>しかし、この方法は推奨されておらず、 Deprecated である。</p>
<h4 ref="412-証明書認証" >4.1.2. 証明書認証</h4><a class="anchor" id="412-証明書認証"></a>
<p>まずは、 SSL/TSL 証明書まわりの復習。</p>
<ul>
<li>SSL/TLS Certificates まわりの登場人物
<ul>
<li>秘密鍵： <code>openssl genrsa 1024 -out server.key</code> （ <code>.key</code> や <code>-key.pem</code> の形式が多い）</li>
<li>公開鍵： <code>openssl rsa -in server.key -pubout &gt; server.pem</code> （ <code>.pem</code> や <code>.crt</code> の形式が多い）</li>
<li>証明書署名要求(CSR / Certificate Signing Request)： <code>openssl req -new -key server.key &gt; server.csr</code> （ <code>.csr</code> の形式が多い）</li>
<li>証明書： <code>openssl x509 -req -days 3650 -signkey server.key &lt; server.csr &gt; server.crt</code> （ <code>.crt</code> や <code>.pem</code> の形式が多い）</li>
</ul>
</li>
<li>証明書の種類
<ul>
<li>サーバ証明書
<ul>
<li>サーバ側が提示する証明書、Webサイトの身分証</li>
<li>サーバ証明書は 認証局/CA が管理する</li>
<li>暗号化に必要な公開鍵が含まれる</li>
</ul>
</li>
<li>クライアント証明書
<ul>
<li>クライアント側が提示する証明書、クライアントの身分証</li>
</ul>
</li>
<li>ルート証明書
<ul>
<li>認証局/CA 自体の正当性をチェックする</li>
<li>サーバ証明書の検証のために使用する証明書</li>
</ul>
</li>
<li>自己証明証明書（オレオレ証明書）
<ul>
<li>正式な認証局ベンダーでなく、個人で構築した認証局などで発行したルート証明書</li>
</ul>
</li>
</ul>
</li>
<li>サーバ証明書
<ul>
<li>「SSL/TSL による通信の暗号化」と「サーバ証明書による本人確認」を実施できる</li>
<li>鍵の送受信は以下のステップ
<ul>
<li>ユーザは「▲公開鍵」「▼秘密鍵」「■サーバ証明書」を作成して、「▲公開鍵」「■サーバ証明書」をサーバに送付</li>
<li>サーバは「■サーバ証明書」を検証し、「●共通鍵」を生成して、「▲公開鍵」により暗号化した「●共通鍵」をユーザに送付</li>
<li>ユーザは受け取った「●共通鍵」を「▼秘密鍵」で復号化</li>
<li>以降、データの送受信を行う際は「●共通鍵」で暗号化・復号化を行う</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>上記の証明書は以下のように利用される。</p>
<ul>
<li><code>kube-apiserver</code> 、 <code>etcd</code> 、 <code>kubelet</code> はサーバ証明書を利用</li>
<li><code>kube-apiserver</code> にアクセスする admin ユーザ、 <code>kube-scheduler</code> 、 <code>kube-controller-manager</code> 、 <code>kube-proxy</code> 、 <code>kubelet</code> はクライアント証明書を利用</li>
<li><code>kubelet</code> 、 <code>etcd</code> にアクセスする <code>kube-apiserver</code> はクライアント証明書を利用</li>
</ul>
<h4 ref="413-鍵証明書の作成方法" >4.1.3. 鍵・証明書の作成方法</h4><a class="anchor" id="413-鍵証明書の作成方法"></a>
<p>上記の通り、サーバ・クライアント証明書が必要な訳だが、それらを管理する認証局/CA を Kubernetes クラスタに作成する必要がある。<br>
まずは、 CA の準備をする。</p>
<ul>
<li>CA の秘密鍵の作成： <code>openssl genrsa 2048 -out ca.key</code></li>
<li>CA の CSR の作成： <code>openssl req -new -key ca.key -subj &quot;/CN=KUBERNETES-CA&quot; -out ca.csr</code></li>
<li>CA の ルート証明書の作成： <code>openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt</code>
<ul>
<li>CA 自身が署名する自己証明書となる</li>
</ul>
</li>
</ul>
<p>なお、 <code>etcd</code> には別途 CA が必要であるため注意が必要。<br>
次に admin ユーザのクライアント証明書を作成する。</p>
<ul>
<li>admin ユーザの秘密鍵の作成： <code>openssl genrsa 2048 -out admin.key</code></li>
<li>admin ユーザの CSR の作成： <code>openssl req -new -key admin.key -subj &quot;/CN=kube-admin/O=system:masters&quot; -out admin.csr</code>
<ul>
<li><code>system:masters</code> の権限で <code>kube-admin</code> アカウントの要求になる</li>
</ul>
</li>
<li>admin ユーザのクライアント証明書の作成： <code>openssl x509 -req -in admin.csr -CA ca.crt -CAkey ca.key -out admin.crt</code>
<ul>
<li>CA に署名してもらう</li>
</ul>
</li>
</ul>
<p>上記の要領で他のクライアント証明書も作成する。<br>
なお、以上で作成した鍵・証明書を用いて kube-admin が <code>kube-apiserver</code> にアクセスする際は以下のようになる。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl https://kube-apiserver:6443/api/v1/pods <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --key admin.key <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --cert admin.crt <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --cacert ca.crt
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml:kube-config.yaml" data-lang="yaml:kube-config.yaml"><span style="color:#75715e"># kubectl を使う場合の kube-config.yaml の設定例</span>
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">clusters</span>:
- <span style="color:#f92672">cluster</span>:
    <span style="color:#f92672">certificate-authority</span>: <span style="color:#ae81ff">ca.crt</span>
    <span style="color:#f92672">server</span>: <span style="color:#ae81ff">https://kube-apiserver:6443</span>
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">kubernetes</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Config</span>
<span style="color:#f92672">users</span>:
- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">kubernetes-admin</span>
  <span style="color:#f92672">user</span>: 
    <span style="color:#f92672">client-certificate</span>: <span style="color:#ae81ff">admin.crt</span>
    <span style="color:#f92672">client-key</span>: <span style="color:#ae81ff">admin.key</span>
</code></pre></div><p>次に <code>kube-apiserver</code> のサーバ証明書を作成する。<br>
（あまり知られていないが <code>kube-apiserver</code> のホスト名は <code>kubernetes</code>）<br>
（つまり、 <code>kubernetes</code> 、 <code>kubernetes.default</code> 、 <code>kubernetes.defalt.svc.cluster.local</code> のような感じで扱われる）</p>
<ul>
<li><code>kube-apiserver</code> の秘密鍵の作成： <code>openssl genrsa 2048 -out apiserver.key</code></li>
<li><code>kube-apiserver</code> の CSR の作成： <code>openssl req -new -key apiserver.key -subj &quot;/CN=kube-apiserver&quot; -out apiserver.csr</code></li>
<li><code>kube-apiserver</code> の サーバ証明書の作成： <code>openssl x509 -req -in apiserver.csr -CA ca.crt -CAkey ca.key -out apiserver.crt</code>
<ul>
<li>CA に署名してもらう</li>
</ul>
</li>
</ul>
<p>なお、<code>kube-apiserver</code> でサーバ証明書を作成する際は <code>openssl.cnf</code> ファイルで以下のように設定しておく必要がある。（ <code>alt_names</code> に注目 ）</p>
<pre><code class="language-txt:openssl.cnf" data-lang="txt:openssl.cnf">[req]
req_extensions = v3_req
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation,
subjectAltName = @alt_names
[alt_names]
DNS.1 = kubernetes
DNS.2 = kubernetes.default
DNS.3 = kubernetes.default.svc
DNS.4 = kubernetes.default.svc.cluster.local
IP.1 = 10.96.0.1   # GlobalIP
IP.2 = 172.17.0.87 # PriveteIP
</code></pre><p>以上のように作成した鍵・証明書を <code>apiserver.service</code> の起動オプションに付与する必要がある。<br>
他のサーバ証明書も同じ要領で作る。</p>
<h4 ref="414-鍵証明書情報の確認方法" >4.1.4. 鍵・証明書情報の確認方法</h4><a class="anchor" id="414-鍵証明書情報の確認方法"></a>
<p>上記のような鍵・証明書を含めた Master/Worker Nodes の構築をスクラッチで行うのは所謂 <strong>The Hard Way</strong> 。<br>
ここでは、 <code>kubeadm</code> を用いて作成した場合の鍵・証明書情報の確認方法について見てみる。</p>
<ul>
<li><code>etc/kubernetes/manifests/</code> 配下に Static Pod として作成されたコンポーネントのマニフェストがある
<ul>
<li>kube-apiserver.yaml 、など</li>
<li>上記の yaml ファイルを確認すれば <code>spec.containers.command</code> に起動コマンドのオプションがあるので、そこで鍵・証明書のパスを確認できる</li>
</ul>
</li>
<li><code>openssl x509 -in /etc/kubernetes/pki/apiserver.crt -txt -noout</code> コマンドで中身が確認できる</li>
<li>以下に各コンポーネントの鍵・証明書の配置や発行者などを一覧化した Excel がある
<ul>
<li><a href="https://github.com/mmumshad/kubernetes-the-hard-way/tree/master/tools">https://github.com/mmumshad/kubernetes-the-hard-way/tree/master/tools</a></li>
</ul>
</li>
</ul>
<h4 ref="415-certificate-api" >4.1.5. Certificate API</h4><a class="anchor" id="415-certificate-api"></a>
<p>jane というユーザが新規に admin ユーザになる場合を想定する。</p>
<ul>
<li>jane の秘密鍵を作成する： <code>openssl genrsa 2048 -out jane.key</code></li>
<li>jane の CSR を作成する： <code>openssl req -new -key jane.key -subj &quot;/CN=jane&quot; -out jane.csr</code></li>
<li>jane の CertificateSigningRequest を作成する： <code>kubectl apply -f jane-csr.yaml</code></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml:jane-csr.yaml" data-lang="yaml:jane-csr.yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">certificates.k8s.io/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">CertificateSigningRequest</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">jane</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">signerName</span>: <span style="color:#ae81ff">kubernetes.io/kube-apiserver-client</span>
  <span style="color:#f92672">groups</span>:
  - <span style="color:#ae81ff">system:authenticated</span>
  <span style="color:#f92672">usages</span>:
  - <span style="color:#ae81ff">digital signature</span>
  - <span style="color:#ae81ff">key encipherment</span>
  - <span style="color:#ae81ff">server auth</span>
  <span style="color:#f92672">request</span>: [ <span style="color:#ae81ff">cat jane.csr | base64 の結果 ]</span>
</code></pre></div><p>参考： <a href="https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers">Kubernetes signers</a></p>
<ul>
<li><code>kubectl get csr</code>
<ul>
<li>Pendding の jane を確認</li>
</ul>
</li>
<li><code>kubectl certificate approve jane</code> ：承認
<ul>
<li>ちなみに <code>kubectl certificate deny jane</code> で却下できる</li>
</ul>
</li>
<li><code>kubectl get csr jane -o yaml</code> ：クライアント証明書の取得</li>
<li>クライアント証明書は Base64 になっているので <code>echo &lt;cert_base64&gt; | base64 --decode</code> でデコード</li>
</ul>
<p>なお、上記の Certificate API は <code>kube-controller-manager</code> によって管理されているので、<code>kube-controller-manager</code> の起動オプション <code>--cluster-signing-cert-file</code> および <code>--cluster-signing-key-file</code> にそれぞれ CA のルート証明書と秘密鍵を設定しておく必要がある。</p>
<h3 ref="42-kubeconfig" >4.2. KubeConfig</h3><a class="anchor" id="42-kubeconfig"></a>
<p>デフォルトでは <code>$HOME/.kube/config</code> にある。<br>
内容は大きく <code>clusters</code> 、 <code>users</code> 、 <code>contexts</code> の 3 領域ある。</p>
<ul>
<li><code>clusters</code> ：アクセス先のクラスタ情報
<ul>
<li>エンドポイントなどの情報はここ</li>
</ul>
</li>
<li><code>users</code> ：アクセス先クラスタのユーザ情報
<ul>
<li>鍵・証明書などの情報はここ</li>
</ul>
</li>
<li><code>contexts</code> ： <code>clusters</code> と <code>users</code> の組合せ</li>
</ul>
<pre><code class="language-yaml:config" data-lang="yaml:config">apiVersion: v1
kind: Config
current-context: ...

clusters:
- name: my-kube-playgroud # ▲
  cluster:
    certificate-authority: /path/to/ca.crt # certificate-authority-data: でベタ貼りもおk
    server: https://my-kube-playgroud:6443
users:
- name: my-kube-admin # ●
  user:
    client-certificate: /path/to/admin.crt
    client-key: /path/to/admin.key

- name: my-kube-admin@my-kube-playground
  context:
    cluster: my-kube-playgroud # ▲
    user: my-kube-admin        # ●
    namespace: ...
</code></pre><ul>
<li><code>kubectl config view</code> コマンドで KubeConfig 情報を閲覧できる</li>
<li><code>kubectl config user-context &lt;context&gt;</code> で current-context の変更</li>
</ul>
<h3 ref="43-rbac" >4.3. RBAC</h3><a class="anchor" id="43-rbac"></a>
<h4 ref="431-role-と-rolebinding" >4.3.1. Role と RoleBinding</h4><a class="anchor" id="431-role-と-rolebinding"></a>
<p>以下のマニフェストで <code>Role</code> を作成できる。（ <code>kubectl apply -f developer-role.yaml</code> ）</p>
<pre><code class="language-yaml:" data-lang="yaml:">apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: developer
  namespace: default
rules:
- apiGroups: [&quot;&quot;]
  resources: [&quot;pods&quot;]
  verbs: [&quot;list&quot;, &quot;get&quot;, &quot;create&quot;, &quot;update&quot;, &quot;delete&quot;]
- apiGroups: [&quot;&quot;]
  resources: [&quot;ConfigMap&quot;]
  verbs: [&quot;create&quot;]
</code></pre><p><code>Role</code> は <code>namespace</code> 毎に有効となる。<br>
次に上記で作成した <code>Role</code> を <code>User</code> に紐づけるための <code>RoleBinding</code> を作成する。（ <code>kubectl apply -f devuser-developer-binding.yaml</code> ）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml:devuser-developer-binding.yaml" data-lang="yaml:devuser-developer-binding.yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">rbac.authorization.k8s.io/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">RoleBinding</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">devuser-developer-binding</span>
<span style="color:#f92672">subjects</span>:
- <span style="color:#f92672">kind</span>: <span style="color:#ae81ff">User</span>
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">dev-user</span>
  <span style="color:#f92672">apiGroup</span>: <span style="color:#ae81ff">rbac.authorization.k8s.io</span>
<span style="color:#f92672">roleRef</span>:
  <span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Role</span>
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">developer</span>
  <span style="color:#f92672">apiGroup</span>: <span style="color:#ae81ff">rbac.authorization.k8s.io</span>
</code></pre></div><p>以上で <code>Role</code> および <code>RoleBinding</code> は作成できる。<br>
なお、繰り返しになるが、 <code>Role</code> は <code>namespace</code> 毎に有効となるため、 <code>pods</code> や <code>services</code> などの <code>namespace</code> を指定して作成するオブジェクトが対象となる。<br>
これらは以下のコマンドで確認する。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Role の確認</span>
$ kubectl get roles
$ kubectl describe role developer

<span style="color:#75715e"># RoleBinding の確認</span>
$ kubectl get rolebindings
$ kubectl describe rolebinding devuser-developer-binding
</code></pre></div><p>なお、各ユーザは自分の権限を以下のコマンドで確認できる。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ kubectl auth can-i create deployments
yes
 
$ kubectl auth can-i delete nodes
no
 
$ kubectl auth can-i create deployments --as dev-user
no
 
$ kubectl auth can-i create pods --as dev-user
yes
 
$ kubectl auth can-i create pods --as dev-user --namespace test
no
</code></pre></div><p>なお、 <code>kubectl api-resources</code> コマンドを利用するとリソースの一覧が取得できる。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ kubectl api-resources
NAME                              SHORTNAMES   APIVERSION                             NAMESPACED   KIND
bindings                                       v1                                     true         Binding
componentstatuses                 cs           v1                                     false        ComponentStatus
configmaps                        cm           v1                                     true         ConfigMap
endpoints                         ep           v1                                     true         Endpoints
events                            ev           v1                                     true         Event
limitranges                       limits       v1                                     true         LimitRange
namespaces                        ns           v1                                     false        Namespace
（省略）
</code></pre></div><h4 ref="432-clusterrole-と-clusterrolebinding" >4.3.2. ClusterRole と ClusterRoleBinding</h4><a class="anchor" id="432-clusterrole-と-clusterrolebinding"></a>
<p><code>namespace</code> 毎に作成するオブジェクトに対して指定する <code>Role</code> に対して、 <code>ClusterRole</code> はクラスタ横断（ <code>namespace</code> 横断）のオブジェクトに対して指定する。<br>
<code>nodes</code> や <code>PV</code> などである。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml:cluster-admin-role.yaml" data-lang="yaml:cluster-admin-role.yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">rbac.authorization.k8s.io/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ClusterRole</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">cluster-administrator</span>
<span style="color:#f92672">rules</span>:
- <span style="color:#f92672">apiGroups</span>: [<span style="color:#e6db74">&#34;&#34;</span>]
  <span style="color:#f92672">resources</span>: [<span style="color:#e6db74">&#34;nodes&#34;</span>]
  <span style="color:#f92672">verbs</span>: [<span style="color:#e6db74">&#34;list&#34;</span>, <span style="color:#e6db74">&#34;get&#34;</span>, <span style="color:#e6db74">&#34;create&#34;</span>, <span style="color:#e6db74">&#34;delete&#34;</span>]
</code></pre></div><p>次に上記で作成した <code>ClusterRole</code> を <code>User</code> に紐づけるための <code>ClusterRoleBinding</code> を作成する。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml:cluster-admin-role-binding.yaml" data-lang="yaml:cluster-admin-role-binding.yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">rbac.authorization.k8s.io/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ClusterRoleBinding</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">cluster-admin-role-binding</span>
<span style="color:#f92672">subjects</span>:
- <span style="color:#f92672">kind</span>: <span style="color:#ae81ff">User</span>
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">cluster-admin</span>
  <span style="color:#f92672">apiGroup</span>: <span style="color:#ae81ff">rbac.authorization.k8s.io</span>
<span style="color:#f92672">roleRef</span>:
  <span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ClusterRole</span>
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">cluster-administrator</span>
  <span style="color:#f92672">apiGroup</span>: <span style="color:#ae81ff">rbac.authorization.k8s.io</span>
</code></pre></div><h3 ref="44-image-security" >4.4. Image Security</h3><a class="anchor" id="44-image-security"></a>
<p>普段マニフェストに記載している <code>image: nginx</code> は省略系で、フルで記載すると <code>image: docker.io/nginx/nginx</code> となる。（なお、 <code>docker.io</code> は Docker Hub の URL）<br>
フォーマットとは <code>image: &lt;Registry&gt;/&lt;User Account&gt;/&lt;Image Repository&gt;</code> で <code>nginx</code> は <code>&lt;Image Repository&gt;</code> のみ記載している。<br>
Private Registory を利用する場合、認証が必要になるが、その際はどうするのか？<br>
以下の通り <code>Secret</code> を利用することになる。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Private Registory 認証用の Secret 作成</span>
$ kubectl create secret docker-registry regcred <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --docker-server<span style="color:#f92672">=</span>private-registry.io <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --docker-username<span style="color:#f92672">=</span>registry-user <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --docker-password<span style="color:#f92672">=</span>registry-password <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --docker-email<span style="color:#f92672">=</span>registry-user@org.com
</code></pre></div><p>上記の Secret を Pod のマニフェストの <code>spec.imagePullSecrets</code> に指定する。</p>
<h3 ref="45-security-context" >4.5. Security Context</h3><a class="anchor" id="45-security-context"></a>
<p>Pod マニフェストの <code>securityContext</code> 項目を設定することにより、コンテナで実行されるプロセスの実行ユーザなどを指定することができる。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">securityContext</span>:
  <span style="color:#f92672">runAsUser</span>: <span style="color:#ae81ff">1000</span>
  <span style="color:#f92672">runAsGroup</span>: <span style="color:#ae81ff">3000</span>
  <span style="color:#f92672">fsGroup</span>: <span style="color:#ae81ff">2000</span>
  <span style="color:#f92672">fsGroupChangePolicy</span>: <span style="color:#e6db74">&#34;OnRootMismatch&#34;</span>
</code></pre></div><p>なお、ユーザを指定しない場合は <code>root</code> ユーザとなる。</p>
<h3 ref="46-network-policy" >4.6. Network Policy</h3><a class="anchor" id="46-network-policy"></a>
<p>NetworkPolicy を適用すれば、 Pod に対して Inress / Egress のトラフィックを制限することができる。<br>
なお、 NetworkPolicy を適用しない場合、全てのトラフィックが許可される。</p>
<ul>
<li>Ingress
<ul>
<li>自分から見て、リクエストを送信するトラフィック</li>
<li>Egress に対するレスポンスは Ingress でないことに注意</li>
</ul>
</li>
<li>Egress
<ul>
<li>自分から見て、リクエストを送信するトラフィック</li>
<li>Ingress に対するレスポンスは Egress でないことに注意</li>
</ul>
</li>
</ul>
<p>例えば、以下の NetworkPolicy は Port 3306 の DB サーバに対して、 api-server からのトラフィックを許可し、その他は遮断するポリシー。<br>
（バックアップ用に DB から cidr:192.168.5.10/32 帯にある Port 80 にアクセスできるようにしている。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">networking.k8s.io/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">NetworkPolicy</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">db-policy</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">podSelector</span>:     <span style="color:#75715e"># policy を適用する Pod の選択</span>
    <span style="color:#f92672">matchLabels</span>:
      <span style="color:#f92672">role</span>: <span style="color:#ae81ff">db</span>
  <span style="color:#f92672">policyTypes</span>:
  - <span style="color:#ae81ff">Ingress</span>
  - <span style="color:#ae81ff">Egress</span>
  <span style="color:#f92672">ingress</span>:
  - <span style="color:#f92672">from</span>:
    - <span style="color:#f92672">podSelector</span>: <span style="color:#75715e"># Ingress を許可する Pod の選択</span>
        <span style="color:#f92672">matchLabels</span>:
          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">api-pod</span>
      <span style="color:#f92672">namespaceSelector</span>: <span style="color:#75715e"># 「-」を見れば分かるがこのルールは上記の PodSelector と and 条件</span>
        <span style="color:#f92672">matchLabels</span>:
          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">prod</span>
    - <span style="color:#f92672">ipBlock</span>: <span style="color:#75715e"># これは or 条件</span>
        <span style="color:#f92672">cidr</span>: <span style="color:#ae81ff">192.168.5.10</span><span style="color:#ae81ff">/32</span>
    <span style="color:#f92672">ports</span>:          <span style="color:#75715e"># Ingress を許可する Port</span>
    - <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
      <span style="color:#f92672">port</span>: <span style="color:#ae81ff">3306</span>
  <span style="color:#f92672">egress</span>:
  - <span style="color:#f92672">to</span>:
    - <span style="color:#f92672">ipBlock</span>:
        <span style="color:#f92672">cidr</span>: <span style="color:#ae81ff">192.168.5.10</span><span style="color:#ae81ff">/32</span>
    <span style="color:#f92672">ports</span>:
    - <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
      <span style="color:#f92672">port</span>: <span style="color:#ae81ff">80</span>
</code></pre></div><p>ネットワークソリューションによっては NetworkPolicy をサポートしていないものがあるので注意。（例えば、 Flannel ）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ kubectl get networkpolicies
</code></pre></div><h2 ref="5-storage" >5. Storage</h2><a class="anchor" id="5-storage"></a>
<p>Docker の場合、以下のコマンドを実行することによってコンテナ内にホストのディレクトリをマウントできる。</p>
<pre><code>$ docker run mysql -v data_volume:/var/lib/mysql
</code></pre><ul>
<li>ホストコンピュータの Docker インストールディレクトリに <code>volumes</code> というディレクトリがある</li>
<li><code>volumes</code> ディレクトリ内に <code>data_volume</code> というディレクトリが作成され、コンテナに関係なく永続化される</li>
<li>ホストの <code>data_volume</code> ディレクトリが、 コンテナの <code>/var/lib/mysql</code> ディレクトリにマウントされる</li>
</ul>
<p>といった動きになる。</p>
<pre><code>$ docker run mysql -v /data/mysql:/var/lib/mysql
</code></pre><ul>
<li>上記のように実行した場合は、ホストの <code>/data/mysql</code> ディレクトリが、コンテナの <code>/var/lib/mysql</code> ディレクトリにマウントされる</li>
</ul>
<p>つまり、 <strong>ホストのとあるディレクトリを Volume と定義して、それをコンテナにマウントする</strong> のが Volume の仕組みだ。<br>
厳密にいうと、前者の例（ <code>data_volume</code> ）のように Volume を定義してマウントする方法を <strong>ボリュームマウンティング</strong> 、後者の例（ <code>/data/mysql</code> ）のようにディレクトリを直接マウントする方法を <strong>バインドマウンティング</strong> という。<br>
厳密なコマンドに直すと以下のようになる。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># バインドマウンティング</span>
$ docker run mysql --mount type<span style="color:#f92672">=</span>bind,source<span style="color:#f92672">=</span>/data/mysql,target<span style="color:#f92672">=</span>/var/lib/mysql
</code></pre></div><p>以上のような Docker の volume 操作は Storage Drivers で実現される。<br>
Storage Driver は Docker プロセスがイメージやコンテナに加えられた変更を差分形式で保持する方式で、上記で 「ディレクトリをマウント」と表現してきたが厳密にはそうではない。<br>
一方 Volume Drivers というものがあり、これは Docker プロセスを経由せずとも、直接コンテナからホストのディレクトリをマウントできる仕組みだ。</p>
<ul>
<li>Storage Drivers
<ul>
<li>AUFS, ZFS, BTRFS, Device Mapper, Overlay, Overlay2 など</li>
</ul>
</li>
<li>Volume Drivers ( Volume Plugin )
<ul>
<li>Local, Azure File Storage, Convoy, DigitalOcean Block Storage, Flocker, gce-docker, GlusterFS, NetApp, RexRay, Portworx, VMware vSphere Storage など</li>
</ul>
</li>
</ul>
<p>Docker で Volume Drivers を利用する方法は以下のようになる。</p>
<pre><code>$ docker run mysql -it \
    --name mysql \
    --volume-driver rexray/ebs |
    --mount src=ebs-vol,target=/var/lib/mysql
</code></pre><p>Kubernetes からは CSI (Container Storage Interface) 準拠した形で上記の機能が呼び出されることになる。</p>
<h3 ref="51-volumes" >5.1. Volumes</h3><a class="anchor" id="51-volumes"></a>
<p>Volume は Pod の <code>spec.volumes</code> で定義し、 <code>spec.containers.volumeMouts</code> で Pod にマウントする。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">random-number-generator</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">containers</span>:
  - <span style="color:#f92672">image</span>: <span style="color:#ae81ff">alpine</span>
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">alpine</span>
    <span style="color:#f92672">command</span>: [<span style="color:#e6db74">&#34;/bin/sh&#34;</span>,<span style="color:#e6db74">&#34;-c&#34;</span>]
    <span style="color:#f92672">args</span>: [<span style="color:#e6db74">&#34;shuf -i 0-100 -n 1 &gt;&gt; /opt/number.out;&#34;</span>]
    <span style="color:#f92672">volumeMounts</span>:
    - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/opt</span>
      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">data-volume</span>
  <span style="color:#f92672">volumes</span>:
  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">data-volume</span>
    <span style="color:#f92672">hostPath</span>:
      <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/data</span>
      <span style="color:#f92672">type</span>: <span style="color:#ae81ff">Directory</span>
</code></pre></div><p>上記の <code>type: Directory</code> の Volume の場合、 Pod がスケジューリングされた Node の <code>/data</code> をマウントする訳だが、同じ ReplicaSet の Pod が同じ Node へスケジューリングされる補償はない。<br>
例えば、下記のように AWS S3 を Volume として定義して利用することもできる。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">volumes</span>:
- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">data-volume</span>
  <span style="color:#f92672">awsElasticBlockStore</span>:
  <span style="color:#f92672">hostPath</span>:
    <span style="color:#f92672">volumeID: &lt;volume-id&gt; path</span>: <span style="color:#ae81ff">/data</span>
    <span style="color:#f92672">fsType</span>: <span style="color:#ae81ff">ext4</span>
</code></pre></div><h3 ref="52-persistent-volumes" >5.2. Persistent Volumes</h3><a class="anchor" id="52-persistent-volumes"></a>
<p>先の Volume では、 Pod マニフェストの <code>spec.volumes</code> に定義するため、 Pod 毎にいちいち設定しなければならない。<br>
Volume の一元管理が可能となるオブジェクトとして <strong>PersistentVolume</strong> がある。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">PersistentVolume</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">pv-vol1</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">accessModes</span>:
  - <span style="color:#ae81ff">ReadWriteOnce</span>
  <span style="color:#f92672">capacity</span>:
    <span style="color:#f92672">storage</span>: <span style="color:#ae81ff">1Gi</span>
  <span style="color:#f92672">awsElasticBlockStore</span>:
    <span style="color:#f92672">volumeID</span>: <span style="color:#ae81ff">&lt;volume-id&gt;</span>
    <span style="color:#f92672">fsType</span>: <span style="color:#ae81ff">ext4</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ kubectl create –f pv-definition.yaml
$ kubectl get persistentvolume
</code></pre></div><h3 ref="53-persistent-volume-claims" >5.3. Persistent Volume Claims</h3><a class="anchor" id="53-persistent-volume-claims"></a>
<p>Claim は「請求」の意。<br>
<strong>PersistentVolumeClaim</strong> を利用すれば、 Kubernetes 上に作成された PersistentVolume の中から条件に合うものを「請求」して取得することができる。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">PersistentVolumeClaim</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">myclaim</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">accessModes</span>:
  - <span style="color:#ae81ff">ReadWriteOnce</span>
  <span style="color:#f92672">resources</span>:
    <span style="color:#f92672">requests</span>:
      <span style="color:#f92672">storage</span>: <span style="color:#ae81ff">500Mi</span>
</code></pre></div><p>例えば、ある PVC を apply して様子を見てみる。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ kubectl get pv,pvc
NAME                      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                   STORAGECLASS   REASON   AGE
persistentvolume/pv0001   1Gi        RWO            Delete           Bound    default/pv-slow-claim   slow                    6m24s

NAME                                  STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE
persistentvolumeclaim/pv-slow-claim   Bound    pv0001   1Gi        RWO            slow           42s
</code></pre></div><p>PVC の条件に合う PV である pv0001 が選ばれ、 PVC の VOLUME 項目に pv0001 が割り当てられているのが分かる。<br>
この PVC を利用して Pod から PV を「請求」するのは以下の通り。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">pvc-slow-test</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">containers</span>:
  - <span style="color:#f92672">image</span>: <span style="color:#ae81ff">alpine</span>
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">alpine</span>
    <span style="color:#f92672">command</span>: [<span style="color:#e6db74">&#34;tail&#34;</span>, <span style="color:#e6db74">&#34;-f&#34;</span>, <span style="color:#e6db74">&#34;/dev/null&#34;</span>]
    <span style="color:#f92672">volumeMounts</span>:
    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">claim-volume</span>
      <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/data</span>
  <span style="color:#f92672">volumes</span>:
  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">claim-volume</span>
    <span style="color:#f92672">persistentVolumeClaim</span>: <span style="color:#75715e"># ここで「請求」してる</span>
      <span style="color:#f92672">claimName</span>: <span style="color:#ae81ff">pv-slow-claim</span>
</code></pre></div><p>マニフェストだけ見ても PVC だけなので、どの PV が割り当てられるか分からない。<br>
上記のマニフェストを apply した後、 describe コマンドなどで確認するしかない。<br>
つまり、 <strong>PV は静的</strong> なのに対して、 <strong>PVC は動的</strong> な Volume 取得方法となる。</p>
<h3 ref="54-storage-class" >5.4. Storage Class</h3><a class="anchor" id="54-storage-class"></a>
<p>PV は静的なオブジェクトなので、例えば、 GCP などのクラウドのストレージをプロビジョンする必要がある場合はその実行を別途行わなければならない。<br>
<strong>StorageClass</strong> はクラウドなどプロビジョニングを要するストレージを動的に確保してくれる。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml:sc-definition.yaml" data-lang="yaml:sc-definition.yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">storage.k8s.io/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">StorageClass</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">google-storage</span>
<span style="color:#f92672">provisioner</span>: <span style="color:#ae81ff">kubernetes.io/gce-pd</span> <span style="color:#75715e"># これを指定する必要あり</span>
</code></pre></div><p>上記の StorageClass を利用して、 PVC を作成する場合は <code>storageClassName</code> 項目で作成した StorageClass を指定する。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml:pvc-definition.yaml" data-lang="yaml:pvc-definition.yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">PersistentVolumeClaim</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">myclaim</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">accessModes</span>:
  - <span style="color:#ae81ff">ReadWriteOnce</span>
  <span style="color:#f92672">storageClassNme</span>: <span style="color:#ae81ff">google-storage</span> <span style="color:#75715e"># これ</span>
  <span style="color:#f92672">resources</span>:
    <span style="color:#f92672">requests</span>:
      <span style="color:#f92672">storage</span>: <span style="color:#ae81ff">500Mi</span>
</code></pre></div><h2 ref="6-networking" >6. Networking</h2><a class="anchor" id="6-networking"></a>
<p>Linux のネットワーク系基本コマンドは以下の通り。</p>
<ul>
<li><code>ip link</code> , <code>ifconfig -a</code> , <code>cat /etc/network/interfaces</code></li>
<li><code>ip addr</code></li>
<li><code>ip addr add 192.168.1.10/24 dev eth0</code></li>
<li><code>ip route</code> : default gateway</li>
<li><code>route</code></li>
<li><code>ip route add 192.168.1.0/24 via 192.168.2.1</code></li>
<li><code>cat /proc/sys/net/ipv4/ip_forward</code></li>
</ul>
<p>Linux の DNS 系基本コマンドは以下の通り。</p>
<ul>
<li><code>cat &quot;192.168.1.11 db&quot; &gt;&gt; /etc/hosts</code></li>
<li><code>cat &quot;nameserver 192.168.1.100&quot; &gt;&gt; /etc/resolv.conf</code></li>
<li><code>nslookup www.google.com</code></li>
<li><code>dig www.google.com</code></li>
</ul>
<p>また、DNS レコードの <code>A</code> とか <code>AAAA</code> とか <code>CNAME</code> とか復習せんとあかんかも、、、</p>
<h3 ref="61-pod-networking" >6.1. Pod Networking</h3><a class="anchor" id="61-pod-networking"></a>
<p>CNI は <code>kubelet</code> の以下のオプションによって設定される。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ kubelet <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --network-;lugin<span style="color:#f92672">=</span>cni <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --cni-conf-dir<span style="color:#f92672">=</span>/etc/cni/net.d <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --cni-bin-dir<span style="color:#f92672">=</span>/etc/cni/bin <span style="color:#75715e"># /opt/cti/bin</span>
$ ./net-script.sh add &lt;container&gt; &lt;namespace&gt;
</code></pre></div><p>CNI 設定ファイルは JSON 形式で以下のようになっている。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
   <span style="color:#f92672">&#34;cniVersion&#34;</span>:<span style="color:#e6db74">&#34;0.2.0&#34;</span>,
   <span style="color:#f92672">&#34;name&#34;</span>:<span style="color:#e6db74">&#34;mynet&#34;</span>,
   <span style="color:#f92672">&#34;type&#34;</span>:<span style="color:#e6db74">&#34;bridge&#34;</span>,
   <span style="color:#f92672">&#34;bridge&#34;</span>:<span style="color:#e6db74">&#34;cni0&#34;</span>,
   <span style="color:#f92672">&#34;isGateway&#34;</span>:<span style="color:#66d9ef">true</span>,
   <span style="color:#f92672">&#34;ipMasq&#34;</span>:<span style="color:#66d9ef">true</span>,
   <span style="color:#f92672">&#34;ipam&#34;</span>:{
      <span style="color:#f92672">&#34;type&#34;</span>:<span style="color:#e6db74">&#34;host-local&#34;</span>,
      <span style="color:#f92672">&#34;subnet&#34;</span>:<span style="color:#e6db74">&#34;10.22.0.0/16&#34;</span>,
      <span style="color:#f92672">&#34;routes&#34;</span>:[
         {
            <span style="color:#f92672">&#34;dst&#34;</span>:<span style="color:#e6db74">&#34;0.0.0.0/0&#34;</span>
         }
      ]
   }
</code></pre></div><h3 ref="62-weave" >6.2. weave</h3><a class="anchor" id="62-weave"></a>
<p>weave は CNI Plugin の 1 つ。<br>
ここでは weave plugin の設定についてみる。<br>
weave のエージェントは Demonset として 各ノートに deploy する。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ kubectl apply -f <span style="color:#e6db74">&#34;https://cloud.weave.works/k8s/net?k8s-version=</span><span style="color:#66d9ef">$(</span>kubectl version | base64 | tr -d <span style="color:#e6db74">&#39;\n&#39;</span><span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>
$ kubectl get pods –n kube-system
</code></pre></div><h3 ref="63-service-networking" >6.3. Service Networking</h3><a class="anchor" id="63-service-networking"></a>
<p><code>kube-proxy</code> には以下のモードがあり、 default は iptables 。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ kube-proxy --proxy-mode <span style="color:#f92672">[</span>userspace | iptables | ipvs <span style="color:#f92672">]</span> ...
</code></pre></div><h3 ref="64-dns" >6.4. DNS</h3><a class="anchor" id="64-dns"></a>
<p>web-service という Service があった場合、以下のように名前登録される。</p>
<ul>
<li>web-service
<ul>
<li>ただし、これは default namespace のみ</li>
</ul>
</li>
<li>web-service.<!-- raw HTML omitted --></li>
<li>web-service.<!-- raw HTML omitted -->.svc</li>
<li>web-service.<!-- raw HTML omitted -->.svc.cluster.local</li>
</ul>
<p>IP アドレスが 10.244.2.5 の Pod があった場合、以下のように名前登録される。</p>
<ul>
<li>10-244-2-5
<ul>
<li>ただし、これは default namespace のみ</li>
</ul>
</li>
<li>10-244-2-5.<!-- raw HTML omitted --></li>
<li>10-244-2-5.<!-- raw HTML omitted -->.pod</li>
<li>10-244-2-5.<!-- raw HTML omitted -->.pod.cluster.local</li>
</ul>
<p>Kubernetes の代表的な DNS である CoreDNS は 2 冗長化された Deployment と ClusterIP として kube-system namespace にデプロイされる。<br>
<code>/etc/coredns/Corefile</code> あたりに設定ファイルがある。もしくは coredns という ConfigMap がある。</p>
<h3 ref="64-ingress" >6.4. Ingress</h3><a class="anchor" id="64-ingress"></a>
<p>Kubernetes のサービスを インターネットに公開する場合、 Service の LoadBalancer を利用する。<br>
LoadBalancer は内部的には NodePortで構成され、 GCP などのプロバイダがロードバランサを構成し、各ノードの NodePort にトラフィックを転送してくれることで成り立っている。（設定だけみると、ただの Service の LoadBalancer だけみ見えるが、じつは、）<br>
しかし、以下の場合はどうだろう。</p>
<ul>
<li>サービスの URL：「https://my-online-store.com」</li>
<li>「https://my-online-store.com/apparel」に該当する Service(LoadBalancer) がある</li>
<li>「https://my-online-store.com/video」に該当する Service(LoadBalancer) がある</li>
</ul>
<p>上記の場合、どのように振り分けを行うのか。<br>
こういう場合に <strong>Ingress</strong> を用いる。<br>
内部的には、Nginx などで実現した <strong>Ingress Controller</strong> と、 ルーティングルールの設定を記載する <strong>Ingress Resource</strong> からなる。<br>
Nginx の場合の Ingress Controller は以下のような Deployment / ConfigMap / Service(NodePort) / ServiceAccont で実現することになる。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">extensions/v1beta1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">nginx-ingress-controller</span>
<span style="color:#f92672">spac</span>:
  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">matchLabels</span>:
      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">nginx-ingress</span>
  <span style="color:#f92672">template</span>:
    <span style="color:#f92672">metadata</span>:
      <span style="color:#f92672">labels</span>:
        <span style="color:#f92672">name</span>: <span style="color:#ae81ff">nginx-ingress</span>
    <span style="color:#f92672">spec</span>:
      <span style="color:#f92672">containers</span>:
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">nginx-ingress-controller</span>
        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.21.0</span>
        <span style="color:#f92672">args</span>:
        - <span style="color:#ae81ff">/nginx-ingress-controller</span>
        <span style="color:#f92672">env</span>:
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">POD_NAME</span>
          <span style="color:#f92672">valueFrom</span>:
            <span style="color:#f92672">fieldRef</span>:
              <span style="color:#f92672">filePath</span>: <span style="color:#ae81ff">metadata.name</span>
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">POD_NAMESPACE</span>
          <span style="color:#f92672">valueFrom</span>:
            <span style="color:#f92672">fieldRef</span>:
              <span style="color:#f92672">filePath</span>: <span style="color:#ae81ff">metadata.namespace</span>
        <span style="color:#f92672">ports</span>:
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">http</span>
          <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">80</span>
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">https</span>
          <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">443</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ConfigMap</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">nginx-configuration</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">nginx-ingress</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">NordPort</span>
  <span style="color:#f92672">ports</span>:
  - <span style="color:#f92672">port</span>: <span style="color:#ae81ff">80</span>
    <span style="color:#f92672">targetPort</span>: <span style="color:#ae81ff">80</span>
    <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">http</span>
  - <span style="color:#f92672">port</span>: <span style="color:#ae81ff">443</span>
    <span style="color:#f92672">targetPort</span>: <span style="color:#ae81ff">443</span>
    <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">https</span>
  <span style="color:#f92672">selectors</span>:
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">nginx-ingress</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ServiceAccount</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">nginx-ingress-serviceaccount</span>
</code></pre></div><p>Ingress Controller 用の Image を使うなど決まりがある。<br>
Ingress Resource は以下のように作成する。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml:Ingress-wear.yaml" data-lang="yaml:Ingress-wear.yaml"><span style="color:#75715e"># 振り分けが無い場合</span>
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">extensions/v1beta1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Ingress</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">ingress-wear</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">backend</span>:
    <span style="color:#f92672">serviceName</span>: <span style="color:#ae81ff">wear-service</span>
    <span style="color:#f92672">servicePort</span>: <span style="color:#ae81ff">80</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml:Ingress-wear-watch.yaml" data-lang="yaml:Ingress-wear-watch.yaml"><span style="color:#75715e"># パスベースの振り分けの場合</span>
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">extensions/v1beta1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Ingress</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">ingress-wear-watch</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">rules</span>:
  - <span style="color:#f92672">http</span>:
      <span style="color:#f92672">paths</span>:
      - <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/wear</span>
        <span style="color:#f92672">backend</span>:
          <span style="color:#f92672">serviceName</span>: <span style="color:#ae81ff">wear-service</span>
          <span style="color:#f92672">servicePort</span>: <span style="color:#ae81ff">80</span>
      - <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/watch</span>
        <span style="color:#f92672">backend</span>:
          <span style="color:#f92672">serviceName</span>: <span style="color:#ae81ff">watch-service</span>
          <span style="color:#f92672">servicePort</span>: <span style="color:#ae81ff">80</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml:Ingress-wear-watch.yaml" data-lang="yaml:Ingress-wear-watch.yaml"><span style="color:#75715e"># ホスト名ベースの振り分けの場合</span>
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">extensions/v1beta1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Ingress</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">ingress-wear-watch</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">rules</span>:
  - <span style="color:#f92672">host</span>: <span style="color:#ae81ff">wear.my-online-store.com</span>
    <span style="color:#f92672">http</span>:
      <span style="color:#f92672">paths</span>:
      - <span style="color:#f92672">backend</span>:
          <span style="color:#f92672">serviceName</span>: <span style="color:#ae81ff">wear-service</span>
          <span style="color:#f92672">servicePort</span>: <span style="color:#ae81ff">80</span>
  - <span style="color:#f92672">host</span>: <span style="color:#ae81ff">watch.my-online-store.com</span>
    <span style="color:#f92672">http</span>:
      <span style="color:#f92672">paths</span>:
      - <span style="color:#f92672">backend</span>:
          <span style="color:#f92672">serviceName</span>: <span style="color:#ae81ff">watch-service</span>
          <span style="color:#f92672">servicePort</span>: <span style="color:#ae81ff">80</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ kubectl apply -f Ingress-wear.yaml
$ kubectl get ingress <span style="color:#75715e"># Ingress Resource のことが ingress</span>
</code></pre></div><p>上記のように、振り分けルールに応じて作成する。</p>
<h2 ref="7-kubeadm" >7. kubeadm</h2><a class="anchor" id="7-kubeadm"></a>
<p><code>kubeadm</code> を使って Kubernetes クラスタを構築してみる。<br>
以下に 1 Master/2 Worker を構築する Vagrant がある。</p>
<ul>
<li><a href="https://github.com/mmumshad/certified-kubernetes-administrator-course">https://github.com/mmumshad/certified-kubernetes-administrator-course</a></li>
</ul>
<h2 ref="8-troubleshooting" >8. Troubleshooting</h2><a class="anchor" id="8-troubleshooting"></a>
<h3 ref="81-application-failure" >8.1. Application Failure</h3><a class="anchor" id="81-application-failure"></a>
<ul>
<li><code>kubectl get all</code> で全体感を確認</li>
<li><code>name</code> や <code>port</code> に誤りが無いか確認</li>
<li>Service の Selector に矛盾がないか確認</li>
<li>DB の ID/Pass などといった環境変数に誤りが無いか確認</li>
</ul>
<h3 ref="82-control-plane-failure" >8.2. Control Plane Failure</h3><a class="anchor" id="82-control-plane-failure"></a>
<ul>
<li><code>kubectl get po -n kube-system</code> で全コンポーネントの稼働を確認</li>
<li>各のプロセスの状態を確認
<ul>
<li><code>service kube-apiserver status</code></li>
<li><code>service kube-controller-manager status</code></li>
<li><code>service kube-scheduler status</code></li>
</ul>
</li>
<li>Worker Nodes のコンポーネントについても忘れず確認
<ul>
<li><code>service kubelet status</code> / <code>systemctl status kubelet</code></li>
<li><code>service kube-proxy status</code></li>
</ul>
</li>
<li>さらにログを確認
<ul>
<li><code>kubectl logs kube-apiserver-master -n kube-system</code></li>
<li><code>sudo journalctl -u kube-apiserver</code>
<ul>
<li><strong>systemd</strong> で管理されたデーモンのログを見るコマンド</li>
<li><code>/usr/lib/systemd/system/xxxx.service</code> という形式で <strong>unit</strong> という単位で管理される（だから <code>-u</code> ）
<ul>
<li><code>etc/systemd/system/xxxx.service.d</code></li>
</ul>
</li>
<li>unit の管理には <code>systemctl</code> コマンドを利用する</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>serviceやsystemctlとは何か？<br>
serviceとsystemctlは、どちらも Linux で楽にコマンドを実行するためのプログラム。</p>
<ul>
<li>service
<ul>
<li>/etc/init.dにあるシェルスクリプトのファイルを指定することで、シェルを実行してくれるもの</li>
<li>例えば、MySQLの実行時にservice mysql startとすると思うが、これは/etc/init.d/mysqlと言うシェルスクリプトにstartと言う引数を与えることで、mysqlを実行している</li>
</ul>
</li>
<li>systemctl
<ul>
<li>/lib/systemdにある設定ファイルを指定して、コマンドを実行するもの</li>
<li>serviceと大きく異なる点は、serviceはシェルを実行するのに対してsystemctlは独自の設定ファイルを使って実行する点だ</li>
</ul>
</li>
</ul>
<p>どちらも使える状態であれば、systemctlを使うのが望ましい。</p>
<h3 ref="83-woker-nodes-failure" >8.3. Woker Nodes Failure</h3><a class="anchor" id="83-woker-nodes-failure"></a>
<ul>
<li><code>kubectl get nodes</code> でノードの状態を確認</li>
<li><code>Ready</code> では無いノードに対して <code>kubectl describe node &lt;node-name&gt;</code> して <code>Unknown</code> の項目を確認</li>
<li>ノードで <code>top</code> <code>df -h</code> などしてリソースの状態を確認</li>
<li><code>kubelet</code> の状態を確認
<ul>
<li><code>service kubelet status</code> / <code>systemctl status kubelet</code></li>
<li><code>sudo journalctl -u kubelet</code>
<ul>
<li>Shift + G でボトムが見れる</li>
</ul>
</li>
</ul>
</li>
<li><code>kubelet</code> の証明書を確認
<ul>
<li><code>openssl x509 -in /var/lib/kubelet/woker-1.crt -text</code></li>
</ul>
</li>
<li><code>kubectl cluster-info</code> でクラスタに関する設定が見れる</li>
</ul>
<h3 ref="84-network-troubleshooting" >8.4. Network Troubleshooting</h3><a class="anchor" id="84-network-troubleshooting"></a>
<ul>
<li>CNI
<ul>
<li><code>kubelet</code> のオプション <code>--cni-bin-dir</code> や <code>--network-plugin</code> を確認</li>
<li>CNI 系の Pod が稼働していることも確認</li>
</ul>
</li>
<li>DNS
<ul>
<li>kubeDNS や coreDNS が稼働していることを確認（ Deployments ）</li>
<li>各々の設定ファイルや ConfigMap を確認</li>
<li><code>proxy . /etc/resolve.conf</code></li>
</ul>
</li>
<li><code>kube-proxy</code>
<ul>
<li>DaemonSet になっているので確認</li>
</ul>
</li>
</ul>
<h2 ref="9-advanced-kubectl" >9. Advanced kubectl</h2><a class="anchor" id="9-advanced-kubectl"></a>
<h3 ref="91-json-pah" >9.1. JSON PAH</h3><a class="anchor" id="91-json-pah"></a>
<p><strong>JSON PATH</strong> を利用したコマンド。（ JSON PATH は <code>metadata.name</code> みたいなやつ）<br>
<code>kubectl</code> は <code>kube-apiserver</code> と JSON 形式で通信しているが、コマンドの結果はユーザに見やすい表形式で、且つ、間引いた情報で出力されている。<br>
<code>-o wide</code> オプションである程度詳細情報まで表示できるが、 <code>-o json</code> オプションを利用すれば全情報が JSON 形式で出力される。<br>
しかし、あまりにも情報が多いので <code>-o=jsonpath=</code> オプションと JSON PATH を利用して情報をフィルタリングできる。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># シングルクオート と 中括弧 で囲む</span>
$ kubectl get po -o<span style="color:#f92672">=</span>jsonpath<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;{ .items[0].spec.containers[0].image }&#39;</span>
<span style="color:#75715e"># 中括弧単位で複数の JSON PATH を指定できる</span>
$ kubectl get po -o<span style="color:#f92672">=</span>jsonpath<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;{ .items[*].metadata.name }{ .items[*].status.capacity.cpu }&#39;</span>
<span style="color:#75715e"># 改行を挟んで見やすくできる</span>
$ kubectl get po -o<span style="color:#f92672">=</span>jsonpath<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;{ .items[*].metadata.name }{&#34;\n&#34;}{ .items[*].status.capacity.cpu }&#39;</span>
</code></pre></div><p><code>range</code> などの JSON PATH の演算子も利用できる。<br>
他にも <code>-o=custom-columns=</code> 、 <code>--sort-by=.metadata.name</code> などのオプションもある。</p>
<h3 ref="92-check-kubeconfig" >9.2. check kubeconfig</h3><a class="anchor" id="92-check-kubeconfig"></a>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ kubectl cluster-info --kubeconfig /root/admin.kubeconfig
</code></pre></div><h2 ref="10-etc" >10. etc</h2><a class="anchor" id="10-etc"></a>
<ul>
<li><a href="https://nishipy.com/archives/1233">「Kubernetes the hard way」を図で理解したい -前編-</a></li>
<li><a href="https://nishipy.com/archives/1304">「Kubernetes the hard way」を図で理解したい -後編-</a></li>
</ul>
		</div>






	
	

      </section>

      
      
    </article>
    
    
    <footer>
      

		
	
			
		
	    	
	  	
	
    </footer>
    



  </body>
</html>
